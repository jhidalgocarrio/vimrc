import os
import sys
import ycm_core
from clang_helpers import PrepareClangFlags

# if no database is found, use this
default_flags = [
    '-Wall',
]

# to be added to _all_ returned flags, always
mandatory_flags = [
    '-Wall',
    '-Wpedantic',
    '-x','c++',
    '-std=c++11',
]

# flags which should never be forwarded to clang (if they are not supported for
# example)
to_be_removed_flags = [
    '-Wno-maybe-uninitialized',
    '-Wno-unused-local-typedefs',
]

# a default
compilation_database_folder = '.'

if os.path.isfile( compilation_database_folder+'/compile_commands.json' ):
  database = ycm_core.CompilationDatabase( compilation_database_folder )
else:
  database = None

SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', ]

# thats it. now some functions

def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
  if not working_directory:
    return list( flags )
  new_flags = []
  make_next_absolute = False
  path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]
  for flag in flags:
    new_flag = flag

    if make_next_absolute:
      make_next_absolute = False
      if not flag.startswith( '/' ):
        new_flag = os.path.join( working_directory, flag )

    for path_flag in path_flags:
      if flag == path_flag:
        make_next_absolute = True
        break

      if flag.startswith( path_flag ):
        path = flag[ len( path_flag ): ]
        new_flag = path_flag + os.path.join( working_directory, path )
        break

    if new_flag:
      new_flags.append( new_flag )
  return new_flags


def IsHeaderFile( filename ):
  extension = os.path.splitext( filename )[ 1 ]
  return extension in [ '.h', '.hxx', '.hpp', '.hh' ]

def find(name, path):
  #sys.stderr.write("looking for " + name + " in " + path + "\n") 
  for root, dirs, files in os.walk(path):
    if name in files:
      return os.path.join(root, name)
  return None

def GetCompilationInfoForFile( filename ):
  # The compilation_commands.json file generated by CMake does not have entries
  # for header files. So we do our best by asking the db for flags for a
  # corresponding source file with the same basename, if any. If one exists,
  # the flags for that file should be good enough.
  if IsHeaderFile( filename ):
    path = os.path.split( filename )[ 0 ] + '/../../../' # forgive me, a very crude heuristic...
    basename = os.path.basename(os.path.splitext( filename )[ 0 ])
    for extension in SOURCE_EXTENSIONS:
      # looking up a file in the filesystem
      replacement_file = find(basename + extension, path)
      if type(replacement_file) is str:
        replacement_file = os.path.abspath(replacement_file)
        if os.path.exists( replacement_file ):
          compilation_info = database.GetCompilationInfoForFile( replacement_file )
          if compilation_info.compiler_flags_:
            return compilation_info
    return None
  return database.GetCompilationInfoForFile( filename )


def FlagsForFile( filename, **kwargs ):
  final_flags = default_flags 
  if database:
    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
    # python list, but a "list-like" StringVec object
    compilation_info = GetCompilationInfoForFile( filename )
    if compilation_info:

      final_flags = PrepareClangFlags(
        MakeRelativePathsInFlagsAbsolute(
          compilation_info.compiler_flags_,
          compilation_info.compiler_working_dir_ ),
        filename)

  # python is a little bit special... ;-) 
  # see http://stackoverflow.com/a/2104348
  clean_flags = [x for x in final_flags if x not in to_be_removed_flags]

  return {
    'flags': mandatory_flags + clean_flags,
    'do_cache': True
  }
